from dataclasses import dataclass
from typing import Any, Callable
from datetime import datetime
import hashlib
import random
import string
import sys
import os
import os.path as osp

from flask import Flask, request, jsonify, Response
from __main__ import app, print_utcnow, parse_utc, USER_DIR, _DEBUG_
from projects import Label, AnnotationPose, ExplicitAnnotation, TrackingAnnotationKeyframe, TrackingAnnotation, Frame, Task, Project

app : Flask
USER_DIR : str
_DEBUG_ : bool


@dataclass
class UserToken:
    token : str
    date : datetime


USER_FILE = 'users.txt'
USER_ROOT = 'root'
USER_TIMEOUT = 15 * 60 # 15 minutes
USER_TOKENS : dict[str, UserToken] = { }
USERS = { }

COOKIE_API_TOKEN = '__cookie_api_token'
COOKIE_USER_NAME = '__cookie_api_uname'


def sha512(string : str) -> str: return hashlib.sha512(string.encode('utf-8')).hexdigest()

def compute_hash(uname : str, passwd : str) -> str: return sha512(sha512(uname + passwd) + uname)


if osp.isfile(osp.join(USER_DIR, USER_FILE)):
    try:
        with open(osp.join(USER_DIR, USER_FILE), 'r') as f:
            for line in f.readlines():
                line = line.strip()
                if not line.startswith('#') and ':' in line:
                    line = line.split(':')
                    USERS[line[0]] = ':'.join(line[1:]) if len(line) > 1 else ''
    except:
        pass

if not USER_ROOT in USERS:
    print(f'''
    ----------------------------------------------------------------------------
    The "{USER_ROOT}" user does not seem to be defined in "{USER_FILE}". We will
    therefore re-add the user "{USER_ROOT}". Please enter the new password for
    "{USER_ROOT}" below.
    ''')
    passw = input()
    USERS[USER_ROOT] = passw
    print(f'''The password for the user "{USER_ROOT}" has been changed to "{passw}".
    You may change it at any time by editing the file "{USER_FILE}".''')

with open(osp.join(USER_DIR, USER_FILE), 'w') as f:
    f.write(f'''# WARNING: THIS IS A PARTIALLY AUTOGENERATED FILE.
# ALL COMMENTS OR INVALID LINES WILL BE LOST ON REGENERATION.
#
# This file contains a list of users allowed to use the YAYAT application.
# Each user is specified by the string <username>:<password>. YATAT further
# requires a root user by the name of "{USER_ROOT}" to be defined.


''' + '\n'.join(f'# {compute_hash(u, USERS[u])}\n{u}:{USERS[u]}' for u in USERS))

if _DEBUG_:
    print(f'''\x1b[1m\x1b[31m
    ╔═══════════════════════════════════════════╗
╭───╢ WARNING: THIS SERVER RUNS IN DEBUG MODE.  ╟───╮
│ ! ║   ALL API AUTHENTICATIONS ARE DISABLED.   ║ ! │
╰───╢ EVERYTHING IS RUNNING AS "ROOT" API USER. ╟───╯
    ╚═══════════════════════════════════════════╝
    \x1b[0m''')


def generate_random_string(length : int) -> str:
    return ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(length))

def json_ok(obj : dict) -> Response:
    return jsonify({
        'date': print_utcnow(),
        'response': obj,
        'error': None
    })

def json_error(error : str, code : int = 400) -> Response:
    resp = jsonify({
        'date': print_utcnow(),
        'response': None,
        'error': error,
    })
    resp.status_code = code
    resp.status = code
    return resp

# don't look too hard at this clusterfuck of a signature, just use it as a decorator.
def secure_api(route : str) -> Callable[[Callable[[str, dict[str, Any]], Response]], Callable[[dict[str, Any]], Response]]:
    def _decorated(callback : Callable[[str, dict[str, Any]], Response]) -> Callable[[dict[str, Any]], Response]:
        @app.route(route, endpoint = callback.__name__)
        def _inner(**kwargs):
            uname = request.cookies[COOKIE_USER_NAME] if COOKIE_USER_NAME in request.cookies else ''
            token = request.cookies[COOKIE_API_TOKEN] if COOKIE_API_TOKEN in request.cookies else ''
            response : Response = json_error('You are not authorized to perform this action.', 403)
            response.delete_cookie(COOKIE_API_TOKEN)
            response.delete_cookie(COOKIE_USER_NAME)

            if _DEBUG_:
                response = callback(USER_ROOT, **kwargs)
            elif uname in USER_TOKENS:
                entry = USER_TOKENS[uname]

                if entry.token == token and (datetime.utcnow() - entry.date).total_seconds() <= USER_TIMEOUT:
                    entry.date = datetime.utcnow()
                    USER_TOKENS[uname] = entry
                    response = callback(uname, **kwargs)

            return response
        return _inner
    return _decorated


# GET:
#   - uname
#   - phash
# Sets login cookies
@app.route('/api/login')
def api_login():
    if (uname := request.args.get('uname', '')) in USERS:
        passwd_hash = request.args.get('phash', '')
        expected_hash = compute_hash(uname, USERS[uname])

        if passwd_hash == expected_hash:
            token = UserToken(generate_random_string(256), datetime.utcnow())
            USER_TOKENS[uname] = token
            resp = json_ok({ })
            resp.set_cookie(COOKIE_API_TOKEN, token.token, int(USER_TIMEOUT))
            resp.set_cookie(COOKIE_USER_NAME, uname, int(USER_TIMEOUT))

            return resp
    return json_error('Invalid login credentials.', 403)


# RETURN:
#   { USER_TOKENS }
# Requires to be ROOT_USER
@secure_api('/api/users/')
def api_users(uname : str):
    if uname == USER_ROOT:
        return json_ok(USER_TOKENS)
    else:
        return json_error('You are not the root user.', 403)


# Deletes the login cookies
@secure_api('/api/logout')
def api_logout(uname : str):
    USER_TOKENS.pop(uname, None)
    response = json_ok({})
    response.delete_cookie(COOKIE_API_TOKEN)
    response.delete_cookie(COOKIE_USER_NAME)
    return response


# Returns all project jsons
@secure_api('/api/projects/')
def api_projects(uname : str):
    return json_ok([p.to_jsonobj() for p in Project.get_existing_projects()])


# GET:
#   - name
# Returns the newly created project json
@secure_api('/api/projects/create')
def api_projects_create(uname : str):
    if (name := request.args.get('name')) is None or any(p for p in Project.get_existing_projects() if p.name == name):
        return json_error('Please provide a non-empty name for the project which has not yet been used.')
    else:
        return json_ok(Project.create_new_project(name, uname).to_jsonobj())


# Returns the project json
@secure_api('/api/projects/<int:project>/')
def api_projects_info(uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        return json_ok(proj.to_jsonobj())


@secure_api('/api/projects/<int:project>/delete')
def api_projects_delete(uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        proj.delete_project()
        return json_ok({ })


# GET:
#   - name
#   - color
# Returns the label json
@secure_api('/api/projects/<int:project>/labels/create')
def api_projects_labels_create(uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (name := request.args.get('name')) is None:
        return json_error('No name has been provided for the label.')
    elif any(l for l in proj.labels if l.name == name):
        return json_error(f'A label with the name "{name}" does already exist.')
    elif (color := request.args.get('color')) is None:
        return json_error('No color has been provided for the label.')
    else:
        return json_ok(proj.add_label(name, color).to_jsonobj())


@secure_api('/api/projects/<int:project>/labels/')
def api_projects_labels(uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        return json_ok([l.to_jsonobj() for l in proj.labels])


@secure_api('/api/projects/<int:project>/labels/<int:label>/')
def api_projects_labels_info(uname : str, project : int, label : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif len(lbl := [l for l in proj.labels if l.id == label]) != 1:
        return json_error(f'Unknown label id "{label}"')
    else:
        return json_ok(lbl[0].to_jsonobj())


@secure_api('/api/projects/<int:project>/labels/<int:label>/change')
def api_projects_labels_change(uname : str, project : int, label : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif len(lbl := [l for l in proj.labels if l.id == label]) != 1:
        return json_error(f'Unknown label id "{label}"')
    else:
        pass # TODO


@secure_api('/api/projects/<int:project>/labels/<int:label>/delete')
def api_projects_labels_delete(uname : str, project : int, label : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif len(lbl := [l for l in proj.labels if l.id == label]) != 1:
        return json_error(f'Unknown label id "{label}"')
    else:
        proj.labels.remove(lbl)
        return json_ok({ })


@secure_api('/api/projects/<int:project>/tasks/create')
def api_projects_tasks(uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        return json_ok([t.to_jsonobj() for t in proj.get_tasks()])


# GET:
#   - name
# Returns the task json
@secure_api('/api/projects/<int:project>/tasks/create')
def api_projects_tasks_create(uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (name := request.args.get('name')) is None:
        return json_error('No name has been provided for the task.')
    elif any(t for t in proj.get_tasks() if t.name == name):
        return json_error(f'A task with the name "{name}" does already exist.')
    else:
        return json_ok(proj.add_task(name, uname).to_jsonobj())


@secure_api('/api/projects/<int:project>/tasks/<int:task>/')
def api_projects_tasks_info(uname : str, project : int, task : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (t := proj.get_task(task)) is None:
        return json_error(f'Invalid task id "{task}" in project "{project}".')
    else:
        return json_ok(t.to_jsonobj())


@secure_api('/api/projects/<int:project>/tasks/<int:task>/delete')
def api_projects_tasks_delete(uname : str, project : int, task : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (t := proj.get_task(task)) is None:
        return json_error(f'Invalid task id "{task}" in project "{project}".')
    else:
        t.delete()
        return json_ok({ })


@secure_api('/api/projects/<int:project>/tasks/<int:task>/upload_data')
def api_projects_tasks_upload_data(uname : str, project : int, task : int):
    pass


@secure_api('/api/projects/<int:project>/tasks/<int:task>/download')
def api_projects_tasks_download(uname : str, project : int, task : int):
    pass


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>')
def api_projects_tasks_frames_info(uname : str, project : int, task : int, frame : int):
    pass


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>/image')
def api_projects_tasks_frames_image(uname : str, project : int, task : int, frame : int):
    pass


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>/change_image')
def api_projects_tasks_frames_change_image(uname : str, project : int, task : int, frame : int):
    pass


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>/change_annotations')
def api_projects_tasks_frames_change_annotations(uname : str, project : int, task : int, frame : int):
    pass


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>/download')
def api_projects_tasks_frames_download(uname : str, project : int, task : int, frame : int):
    pass
