from dataclasses import dataclass
from typing import Any, Callable
from datetime import datetime
import hashlib
import urllib
import random
import string
import re
import io
import os
import os.path as osp

from flask import Flask, request, jsonify, Response
from __main__ import app, print_utcnow, print_utc, parse_utc, utc_from_unix, USER_DIR, _DEBUG_
from projects import *

app : Flask
USER_DIR : str
_DEBUG_ : bool


@dataclass
class UserToken:
    token : str
    date : datetime


USER_FILE = 'users.txt'
USER_ROOT = 'root'
USER_TIMEOUT = 15 * 60 # 15 minutes
USER_TOKENS : dict[str, UserToken] = { }
USERS = { }

COOKIE_API_TOKEN = '__cookie_api_token'
COOKIE_USER_NAME = '__cookie_api_uname'

task_upload_updates : dict[tuple[int, int], list[str]] = { }
task_download_updates : dict[tuple[int, int], list[str]] = { }


def sha512(string : str) -> str: return hashlib.sha512(string.encode('utf-8')).hexdigest()

def compute_hash(uname : str, passwd : str) -> str: return sha512(sha512(uname + passwd) + uname)

def add_task_upload_update(project : int, task : int, message : str) -> None:
    updates = task_upload_updates.get((project, task), [])
    updates.append(message) # TODO : add timestamp
    task_upload_updates[(project, task)] = updates

def add_task_download_update(project : int, task : int, message : str) -> None:
    updates = task_download_updates.get((project, task), [])
    updates.append(message) # TODO : add timestamp
    task_download_updates[(project, task)] = updates



if osp.isfile(osp.join(USER_DIR, USER_FILE)):
    try:
        with open(osp.join(USER_DIR, USER_FILE), 'r') as f:
            for line in f.readlines():
                line = line.strip()
                if not line.startswith('#') and ':' in line:
                    line = line.split(':')
                    USERS[line[0]] = ':'.join(line[1:]) if len(line) > 1 else ''
    except:
        pass

if not USER_ROOT in USERS:
    print(f'''
    ----------------------------------------------------------------------------
    The "{USER_ROOT}" user does not seem to be defined in "{USER_FILE}". We will
    therefore re-add the user "{USER_ROOT}". Please enter the new password for
    "{USER_ROOT}" below.
    ''')
    passw = input()
    USERS[USER_ROOT] = passw
    print(f'''The password for the user "{USER_ROOT}" has been changed to "{passw}".
    You may change it at any time by editing the file "{USER_FILE}".''')

with open(osp.join(USER_DIR, USER_FILE), 'w') as f:
    f.write(f'''# WARNING: THIS IS A PARTIALLY AUTOGENERATED FILE.
# ALL COMMENTS OR INVALID LINES WILL BE LOST ON REGENERATION.
#
# This file contains a list of users allowed to use the YAYAT application.
# Each user is specified by the string <username>:<password>. YATAT further
# requires a root user by the name of "{USER_ROOT}" to be defined.


''' + '\n'.join(f'# {compute_hash(u, USERS[u])}\n{u}:{USERS[u]}' for u in USERS))

if _DEBUG_:
    print(f'''\x1b[1m\x1b[31m
    ╔═══════════════════════════════════════════╗
╭───╢ WARNING: THIS SERVER RUNS IN DEBUG MODE.  ╟───╮
│ ! ║   ALL API AUTHENTICATIONS ARE DISABLED.   ║ ! │
╰───╢ EVERYTHING IS RUNNING AS "ROOT" API USER. ╟───╯
    ╚═══════════════════════════════════════════╝
    \x1b[0m''')


def generate_random_string(length : int) -> str:
    return ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(length))

def json_ok(obj : dict) -> Response:
    return jsonify({
        'date': print_utcnow(),
        'response': obj,
        'error': None
    })

def json_error(error : str, code : int = 400) -> Response:
    resp = jsonify({
        'date': print_utcnow(),
        'response': None,
        'error': error,
    })
    resp.status_code = code
    resp.status = code
    return resp


def get_logged_in_name() -> str | None:
    if _DEBUG_:
        return USER_ROOT
    else:
        uname = request.cookies[COOKIE_USER_NAME] if COOKIE_USER_NAME in request.cookies else ''
        token = request.cookies[COOKIE_API_TOKEN] if COOKIE_API_TOKEN in request.cookies else ''

        if uname in USER_TOKENS:
            entry = USER_TOKENS[uname]
            if entry.token == token and (datetime.utcnow() - entry.date).total_seconds() <= USER_TIMEOUT:
                return uname
    return None


# don't look too hard at this clusterfuck of a signature, just use it as a decorator.
def secure_api(route : str) -> Callable[[Callable[[str, dict[str, Any]], Response]], Callable[[dict[str, Any]], Response]]:
    def _decorated(callback : Callable[[str, dict[str, Any]], Response]) -> Callable[[dict[str, Any]], Response]:
        @app.route(route, endpoint = callback.__name__, methods = ['GET', 'POST'])
        def _inner(**kwargs):
            uname = get_logged_in_name()
            response : Response = json_error('You are not authorized to perform this action.', 403)
            response.delete_cookie(COOKIE_API_TOKEN)
            response.delete_cookie(COOKIE_USER_NAME)

            if uname is not None:
                if uname in USER_TOKENS:
                    entry = USER_TOKENS[uname]
                    entry.date = datetime.utcnow()
                    USER_TOKENS[uname] = entry
                response = callback(uname = uname, args = request.get_json(silent = True) or request.args or { }, **kwargs)

            return response
        return _inner
    return _decorated


# POST:
#   { uname : str, phash : str }
# Sets login cookies
@app.route('/api/login', methods = ['GET', 'POST'])
def api_login():
    args = request.get_json() or request.args

    if (uname := args.get('uname', '')) in USERS:
        passwd_hash = args.get('phash', '')
        expected_hash = compute_hash(uname, USERS[uname])

        if passwd_hash == expected_hash:
            token = UserToken(generate_random_string(256), datetime.utcnow())
            USER_TOKENS[uname] = token
            resp = json_ok({ })
            resp.set_cookie(COOKIE_API_TOKEN, token.token, int(USER_TIMEOUT))
            resp.set_cookie(COOKIE_USER_NAME, uname, int(USER_TIMEOUT))

            return resp
    return json_error('Invalid login credentials.', 403)


# RETURN:
#   { USER_TOKENS }
# Requires to be ROOT_USER
@secure_api('/api/users/')
def api_users(args : dict, uname : str):
    if uname == USER_ROOT:
        return json_ok(USER_TOKENS)
    else:
        return json_error('You are not the root user.', 403)


# Deletes the login cookies
@secure_api('/api/logout')
def api_logout(args : dict, uname : str):
    USER_TOKENS.pop(uname, None)
    response = json_ok({})
    response.delete_cookie(COOKIE_API_TOKEN)
    response.delete_cookie(COOKIE_USER_NAME)
    return response


# Returns all project jsons
@secure_api('/api/projects/')
def api_projects(args : dict, uname : str):
    return json_ok([p.to_jsonobj() for p in Project.get_existing_projects()])


# POST:
#   { name : str }
# Returns the newly created project json
@secure_api('/api/projects/create')
def api_projects_create(args : dict, uname : str):
    if (name := request.args.get('name')) is None or any(p for p in Project.get_existing_projects() if p.name == name):
        return json_error('Please provide a non-empty name for the project which has not yet been used.')
    else:
        return json_ok(Project.create_new_project(name, uname).to_jsonobj())


# Returns the project json
@secure_api('/api/projects/<int:project>/')
def api_projects_info(args : dict, uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        return json_ok(proj.to_jsonobj())


@secure_api('/api/projects/<int:project>/delete')
def api_projects_delete(args : dict, uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        proj.delete_project()
        return json_ok({ })


# POST:
#   { name : str, color : str }
# Returns the label json
@secure_api('/api/projects/<int:project>/labels/create')
def api_projects_labels_create(args : dict, uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (name := args.get('name')) is None:
        return json_error('No name has been provided for the label.')
    elif any(l for l in proj.labels if l.name == name):
        return json_error(f'A label with the name "{name}" does already exist.')
    elif (color := args.get('color')) is None:
        return json_error('No color has been provided for the label.')
    else:
        return json_ok(proj.add_label(name, color).to_jsonobj())


@secure_api('/api/projects/<int:project>/labels/')
def api_projects_labels(args : dict, uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        return json_ok([l.to_jsonobj() for l in proj.labels])


@secure_api('/api/projects/<int:project>/labels/<int:label>/')
def api_projects_labels_info(args : dict, uname : str, project : int, label : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif len(lbl := [l for l in proj.labels if l.id == label]) != 1:
        return json_error(f'Unknown label id "{label}"')
    else:
        return json_ok(lbl[0].to_jsonobj())


@secure_api('/api/projects/<int:project>/labels/change')
def api_projects_labels_change_all(args : dict, uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        pass # TODO


@secure_api('/api/projects/<int:project>/labels/<int:label>/change')
def api_projects_labels_change(args : dict, uname : str, project : int, label : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif len(lbl := [l for l in proj.labels if l.id == label]) != 1:
        return json_error(f'Unknown label id "{label}"')
    else:
        pass # TODO


@secure_api('/api/projects/<int:project>/labels/<int:label>/delete')
def api_projects_labels_delete(args : dict, uname : str, project : int, label : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif len(lbl := [l for l in proj.labels if l.id == label]) != 1:
        return json_error(f'Unknown label id "{label}"')
    else:
        proj.labels.remove(lbl)
        return json_ok({ })


@secure_api('/api/projects/<int:project>/tasks/')
def api_projects_tasks(args : dict, uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    else:
        return json_ok([t.to_jsonobj() for t in proj.get_tasks()])


@secure_api('/api/tasks/')
@secure_api('/api/projects/tasks/')
def api_all_tasks(args : dict, uname : str):
    return json_ok([
        t.to_jsonobj()
        for p in Project.get_existing_projects()
        for t in p.get_tasks()
    ])


# POST:
#   { name : str }
# Returns the task json
@secure_api('/api/projects/<int:project>/tasks/create')
def api_projects_tasks_create(args : dict, uname : str, project : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (name := args.get('name', None)) is None:
        return json_error('No name has been provided for the task.')
    elif len(name.strip()) < 1:
        return json_error('The task\'s name must not be empty or only consisting of whitespaces.')
    elif any(t for t in proj.get_tasks() if t.name == name):
        return json_error(f'A task with the name "{name}" does already exist.')
    else:
        return json_ok(proj.add_task(name, uname).to_jsonobj())


@secure_api('/api/projects/<int:project>/tasks/<int:task>/')
def api_projects_tasks_info(args : dict, uname : str, project : int, task : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (t := proj.get_task(task)) is None:
        return json_error(f'Invalid task id "{task}" in project "{project}".')
    else:
        return json_ok(t.to_jsonobj())


@secure_api('/api/projects/<int:project>/tasks/<int:task>/delete')
def api_projects_tasks_delete(args : dict, uname : str, project : int, task : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (t := proj.get_task(task)) is None:
        return json_error(f'Invalid task id "{task}" in project "{project}".')
    else:
        t.delete()
        return json_ok({ })


@secure_api('/api/projects/<int:project>/tasks/<int:task>/completed')
def api_projects_tasks_completed(args : dict, uname : str, project : int, task : int):
    pass # TODO


# POST [multipart/form-data]:
#   {
#       <uuid> : [<file>],
#       files : str = json(
#           list[{
#               file : str,
#               uuid : str,
#               type : ['s', 'u', 'w']
#           }]
#       )
#   }
# RETURN:
#   [ Frame ]
@secure_api('/api/projects/<int:project>/tasks/<int:task>/upload')
def api_projects_tasks_upload(args : dict, uname : str, project : int, task : int):
    if (proj := Project.get_existing_project(project)) is None:
        return json_error(f'Invalid project id "{project}".')
    elif (t := proj.get_task(task)) is None:
        return json_error(f'Invalid task id "{task}" in project "{project}".')
    else:
        try:
            frames : list[Frame] = []
            files = json.loads(request.form.get('files', []))
        except Exception as e:
            return json_error(f'Invalid form submission data: {e}')

        task_upload_updates[(project, task)] = []

        for file in files:
            try:
                bytes = None

                add_task_upload_update(project, task, f'Reading bytes from "{file["file"]}" ...')

                match origin := FrameOrigin(file['type']):
                    case FrameOrigin.SERVER:
                        with open(file['file'], 'rb') as f:
                            bytes = bytearray(f.read())
                    case FrameOrigin.UPLOAD:
                        if (file_obj := request.files.get(file['uuid'], None)) is not None:
                            bytes = bytearray(file_obj.stream.read())
                    case FrameOrigin.WEBURL:
                        req = urllib.request.urlopen(file['file'])
                        bytes = bytearray(req.read())

                for framenum, image in enumerate(read_images(
                        bytes,
                        lambda msg: add_task_upload_update(project, task, f'Extracting frames from "{file["file"]}": {msg}')
                    )):
                    add_task_upload_update(project, task, f'Creating frame {framenum + 1} from "{file["file"]}" ...')

                    frame = t.add_frame(image, file['file'], origin)

                    if frame.deleted:
                        t.delete_frame(frame, True)
                    else:
                        frames.append(frame)
            except Exception as e:
                pass # TODO

        with open(t.upload_file, 'w') as f:
            f.writelines(task_upload_updates[(project, task)])

        return json_ok([f.to_jsonobj() for f in frames])


@secure_api('/api/projects/<int:project>/tasks/<int:task>/upload/progress')
def api_projects_tasks_upload_progress(args : dict, uname : str, project : int, task : int):
    return json_ok(task_upload_updates.get((project, task), []))


@secure_api('/api/projects/<int:project>/tasks/<int:task>/download')
def api_projects_tasks_download(args : dict, uname : str, project : int, task : int):
    pass # TODO


@secure_api('/api/projects/<int:project>/tasks/<int:task>/download/progress')
def api_projects_tasks_download_progress(args : dict, uname : str, project : int, task : int):
    return json_ok(task_download_updates.get((project, task), []))


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>')
def api_projects_tasks_frames_info(args : dict, uname : str, project : int, task : int, frame : int):
    pass # TODO


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>/image')
def api_projects_tasks_frames_image(args : dict, uname : str, project : int, task : int, frame : int):
    pass # TODO


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>/change_image')
def api_projects_tasks_frames_change_image(args : dict, uname : str, project : int, task : int, frame : int):
    pass # TODO


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>/change_annotations')
def api_projects_tasks_frames_change_annotations(args : dict, uname : str, project : int, task : int, frame : int):
    pass # TODO


@secure_api('/api/projects/<int:project>/tasks/<int:task>/frames/<int:frame>/download')
def api_projects_tasks_frames_download(args : dict, uname : str, project : int, task : int, frame : int):
    pass # TODO


def human_readable_size(num : int | float, scale : int | float = 1024.0, suffix = 'B', si_prefixes : list[str] = list('kMGTPEZY')) -> str:
    for unit in [''] + si_prefixes:
        if abs(num) < scale:
            return f"{num:3.2f} {unit}{suffix}"
        num /= scale
    return '(way too fucking large, bro)'

# POST:
#   { dir : str }
# RETURN:
#   {
#       dir : str,
#       files : list[{
#            name : str,
#            path : str,
#            type : 'd' or 'f',
#            size : str,
#            created : datetime,
#            modified : datetime
#       }]
#   }
@secure_api('/api/filesystem')
def api_filesystem(args : dict, uname : str):
    if (dir := args.get('dir', None)) is None:
        return json_error('No directory has been provided.')
    elif not osp.isdir(dir):
        return json_error(f'Unknown directory "{dir}"')
    else:
        def _normpath(path : str) -> str:
            return path.replace('\\', '/')

        files = os.listdir(dir)
        files.sort(key = lambda f: osp.splitext(f)[::-1])
        files.sort(key = lambda f: not osp.isdir(osp.join(dir, f)))
        files.insert(0, '..')
        isroot = re.match('^(\\.?/|[a-zA-Z]:/?|)\\.\\./?$', _normpath(dir)) is not None
        dir = osp.normpath(dir)

        if isroot: # list drives on windows
            files = [chr(x) + ':/' for x in range(65, 91) if os.path.exists(chr(x) + ':')]

        filtered_files = []

        for file in files:
            if isroot:
                path = file
            elif file == '..' and (_normpath(dir) == '/' or _normpath(dir).endswith(':/')):
                path = '/..'
            else:
                path = osp.normpath(osp.join(dir, file))

            isdir = osp.isdir(path)

            if isdir or path.lower().endswith(tuple(VALID_IMAGE_EXTENSIONS + VALID_VIDEO_EXTENSIONS)):
                stat = os.stat(path)
                filtered_files.append({
                    'name': file + os.sep if isdir else file,
                    'path': _normpath(path),
                    'type': 'd' if isdir else 'f',
                    'size': human_readable_size(stat.st_size),
                    'created': print_utc(utc_from_unix(stat.st_ctime)),
                    'modified': print_utc(utc_from_unix(stat.st_mtime)),
                })

        return json_ok({
            'dir': _normpath(dir),
            'files': filtered_files
        })



